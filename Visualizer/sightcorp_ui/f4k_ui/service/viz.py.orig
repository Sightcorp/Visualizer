import logging
from f4k_ui.db import util
#from f4k_ui.db.models import Video, SummaryCamera37
from f4k_ui.db.models import Person, Source
from f4k_ui.parameters import VisualizationParameters

class VizService:
    def __init__(self, species_names):
        self.species_names = species_names

    def process_request(self, request):
        parameters = VisualizationParameters(request, self.species_names)
        #? Change into: parameters = VisualizationParameters(request)
        logging.info("Requesting Chart - data: %s" % parameters)

        data = None
        t = parameters.t().lower()
        z = parameters.z().lower()
        if t == 's':
            data = self.simple(parameters)
        elif t == 't':
            #if z == 's':
            #    data = self.stacked_species(parameters)
            #el
            if z == "c":
                data = self.stacked_cameras(parameters)
            if z == "d":
                data = self.stacked_days(parameters)
            if z == "h":
                data = self.stacked_hours(parameters)
            if z == "mood":
                data = self.stacked_moods(parameters)
            if z == "gen":
                data = self.stacked_genders(parameters)
            if z == "age":
                data = self.stacked_ages(parameters)
            if z == "hap":
                data = self.stacked_happys(parameters)
            if z == "dis":
                data = self.stacked_disgusteds(parameters)
            if z == "ang":
                data = self.stacked_angrys(parameters)
            if z == "sur":
                data = self.stacked_surpriseds(parameters)
            if z == "afr":
                data = self.stacked_afraids(parameters)
            if z == "sad":
                data = self.stacked_sads(parameters)
        #elif t == 'b':
        #    if z == "w":
        #        data = self.hourly_distribution_aggregated_by_week(parameters)

        if data is None:
            logging.warning('Dimensions t: %s, z: %s is NOT implemented.' % (t, z))

        logging.debug("Response Chart - computed.")
        return {'viz': data}

    def simple(self, parameters):
        x_axis = parameters.x().lower()
        #if x_axis == 'w':
        #    counts = [[i,0] for i in range(53)]
        if x_axis == 'd':
            counts = [[i,0] for i in range(4,7)]
        elif x_axis == 'h':
            counts = [[i,0] for i in range(24)]
        elif x_axis == 'c':
            counts = [[i,0] for i in range(1,4)]
        elif x_axis == 'mood':
            counts = [[i,0] for i in [35,40,45,50,55]]
        else:
            counts = []

        #count = Person.objects.person_count(x_axis, parameters)
        count = Person.objects.person_count(x_axis, parameters)
        counts = util.add_counts_multicol(counts, count)
        #for camera in parameters.computed_camera_tables():
        #    count = camera.objects.raw_fish_count(x_axis, parameters, camera._meta.db_table)
        #    counts = util.add_counts_multicol(counts, count)

        return counts

    def stacked_cameras(self, parameters):
        res = None
        y = parameters.y().lower()
        if y == 'np':
            res = self.cameras_decomposition_raw(parameters)
        return self.fix_missing_x_groupings(res)
    def stacked_days(self, parameters):
        res = None
        y = parameters.y().lower()
        if y == 'np':
            res = self.days_decomposition_raw(parameters)
        return self.fix_missing_x_groupings(res)
    def stacked_hours(self, parameters):
        res = None
        y = parameters.y().lower()
        if y == 'np':
            res = self.hours_decomposition_raw(parameters)
        return self.fix_missing_x_groupings(res)
    def stacked_moods(self, parameters):
        res = None
        y = parameters.y().lower()
        if y == 'np':
            res = self.moods_decomposition_raw(parameters)
        return self.fix_missing_x_groupings(res)
    def stacked_genders(self, parameters):
        res = None
        y = parameters.y().lower()
        if y == 'np':
            res = self.genders_decomposition_raw(parameters)
        return self.fix_missing_x_groupings(res)
    def stacked_ages(self, parameters):
        res = None
        y = parameters.y().lower()
        if y == 'np':
            res = self.ages_decomposition_raw(parameters)
        return self.fix_missing_x_groupings(res)
    def stacked_happys(self, parameters):
        res = None
        y = parameters.y().lower()
        if y == 'np':
            res = self.happys_decomposition_raw(parameters)
        return self.fix_missing_x_groupings(res)
    def stacked_surpriseds(self, parameters):
        res = None
        y = parameters.y().lower()
        if y == 'np':
            res = self.surpriseds_decomposition_raw(parameters)
        return self.fix_missing_x_groupings(res)
    def stacked_angrys(self, parameters):
        res = None
        y = parameters.y().lower()
        if y == 'np':
            res = self.angrys_decomposition_raw(parameters)
        return self.fix_missing_x_groupings(res)
    def stacked_afraids(self, parameters):
        res = None
        y = parameters.y().lower()
        if y == 'np':
            res = self.afraids_decomposition_raw(parameters)
        return self.fix_missing_x_groupings(res)
    def stacked_sads(self, parameters):
        res = None
        y = parameters.y().lower()
        if y == 'np':
            res = self.sads_decomposition_raw(parameters)
        return self.fix_missing_x_groupings(res)

        '''
        video_counts = Video.objects.video_counts(x_axis, parameters)

        species_counts = None
        if x_axis == 'spec':
            # Watch out here! We're not grouping by species because the system
            # never does.
            total_number_of_videos = video_counts[0][0]
            video_counts = dict((spec, total_number_of_videos) for spec in parameters.filter_species())
        else:
            video_counts = dict(video_counts)

            # This is in the 'else' because counting species per species
            # would be stupid
            camera_tblnames = (camera._meta.db_table for camera in parameters.computed_camera_tables())
            # An arbitrary camera is needed to get at the objects manager.
            # There is no reason why this is SummaryCamera37.
            species_counts = dict(SummaryCamera37.objects.species_count(x_axis, parameters, camera_tblnames))

        filter = None
        if x_axis == 'y':
            filter = parameters.filter_year()
        elif x_axis == 'w':
            filter = parameters.filter_week()
        elif x_axis == 'h':
            filter = parameters.filter_hour()
        elif x_axis == 'spec':
            filter = parameters.filter_species()
        # Add video counts and filter
        counts = [c + [int(c[0] in filter), video_counts.get(c[0], 0)] for c in counts]
        # Add NFC
        counts = [c + [util.safe_division(c[1], c[3])] for c in counts]
        # Add species count
        if species_counts:
            counts = [c + [species_counts.get(c[0], 0)] for c in counts]
        '''
    
    '''
    def stacked_species(self, parameters):
        res = None
        y = parameters.y().lower()
        if y == 'fc':
            res = self.species_decomposition_raw(parameters)
        elif y == 'nfc':
            res = self.species_decomposition_normalized(parameters)

        return self.fix_missing_x_groupings(res)
    '''

    '''
    def species_decomposition_raw(self, parameters):
        grouping = self.define_grouping_for_x_axis(parameters)
        res = []
        for sp in parameters.filter_species():
            counts = [[i, 0] for i in sorted(grouping)]
            tempSpec = [sp]
            for camera in parameters.computed_camera_tables():
                count = camera.objects.raw_fish_count(parameters.x(), parameters, camera._meta.db_table, tempSpec)
                counts = util.add_stacked_counts(count, counts)
                # add specie to the list only if it has been detected with this filter parameters(summed count >0)
            if sum(x[1] for x in counts):
                specRes = {'values': counts}
                specRes.update({'key': str(sp)})
                res.append(specRes)
        return res

    def species_decomposition_normalized(self, parameters):
        grouping = self.define_grouping_for_x_axis(parameters)
        res = []

        video_counts = dict(Video.objects.video_counts(parameters.x(), parameters))

        #loop through all the species, get count for each specie, add individual counts to the general array of counts.
        for sp in parameters.filter_species():
            counts = [[i, 0] for i in sorted(grouping)]
            tempSpec = [sp]
            for camera in parameters.computed_camera_tables():
                count = camera.objects.raw_fish_count(parameters.x(), parameters, camera._meta.db_table, tempSpec)
                counts = util.add_stacked_counts(count, counts)

            # normalize counts: count of fish per species/count of videos
            for c in counts:
                for v in video_counts.keys():
                    if v == c[0]:
                        c[1] = c[1] / video_counts[v]

            if not sum(x[1] for x in counts) == 0:
                specRes = {'values': counts}
                specRes.update({'key': str(sp)})
                res.append(specRes)
        return res

    def cameras_decomposition_normalized(self, parameters):
        counts = self.cameras_decomposition_raw(parameters)

        video_counts = Video.objects.video_counts(parameters.x(), parameters)

        if parameters.x().lower() == 'spec':
            # Watch out here! We're not grouping by species because the system
            # never does.
            total_number_of_videos = video_counts[0][0]
            video_counts = dict((spec, total_number_of_videos) for spec in parameters.filter_species())
        else:
            video_counts = dict(video_counts)

        # normalize counts: count of fish per species/count of videos
        for camera_counts in counts:
            for camera_count in camera_counts['values']:
                for v in video_counts.keys():
                    if v == camera_count[0]:
                        camera_count[1] = camera_count[1] / video_counts[v]

        return counts

    def cameras_decomposition_species(self, parameters):
        grouping = self.define_grouping_for_x_axis(parameters)
        res = []
        for camera in parameters.computed_camera_tables():
            counts = [[i, 0] for i in sorted(grouping)]
            count = camera.objects.species_count(parameters.x(), parameters, [camera._meta.db_table])
            counts = util.add_stacked_counts(count, counts)

            camRes = {'values': counts}
            key = camera._meta.db_table.split('_')[2]
            camRes.update({'key': key})
            res.append(camRes)
        return res
    '''

#############################        

    def cameras_decomposition_raw(self, parameters):
        grouping = self.define_grouping_for_x_axis(parameters)
        res = []
        for item in parameters.filter_cameras():
            counts = [[i, 0] for i in sorted(grouping)]
            count = Person.objects.person_count(parameters.x(), parameters)
            counts = util.add_stacked_counts(count, counts)
            layerRes = {'values': counts}
            key = item
            layerRes.update({'key': key})
            res.append(layerRes)
        return res
    def days_decomposition_raw(self, parameters):
        grouping = self.define_grouping_for_x_axis(parameters)
        res = []
        for item in parameters.filter_days():
            counts = [[i, 0] for i in sorted(grouping)]
            count = Person.objects.person_count(parameters.x(), parameters)
            counts = util.add_stacked_counts(count, counts)
            layerRes = {'values': counts}
            key = item
            layerRes.update({'key': key})
            res.append(layerRes)
        return res
    def hours_decomposition_raw(self, parameters):
        grouping = self.define_grouping_for_x_axis(parameters)
        res = []
        for item in parameters.filter_hours():
            counts = [[i, 0] for i in sorted(grouping)]
            count = Person.objects.person_count(parameters.x(), parameters)
            counts = util.add_stacked_counts(count, counts)
            layerRes = {'values': counts}
            key = item
            layerRes.update({'key': key})
            res.append(layerRes)
        return res
    def moods_decomposition_raw(self, parameters):
        grouping = self.define_grouping_for_x_axis(parameters)
        res = []
        for item in parameters.filter_moods():
            counts = [[i, 0] for i in sorted(grouping)]
            count = Person.objects.person_count(parameters.x(), parameters)
            counts = util.add_stacked_counts(count, counts)
            layerRes = {'values': counts}
            key = item
            layerRes.update({'key': key})
            res.append(layerRes)
        return res
    def genders_decomposition_raw(self, parameters):
        grouping = self.define_grouping_for_x_axis(parameters)
        res = []
        for item in parameters.filter_genders():
            counts = [[i, 0] for i in sorted(grouping)]
            count = Person.objects.person_count(parameters.x(), parameters)
            counts = util.add_stacked_counts(count, counts)
            layerRes = {'values': counts}
            key = item
            layerRes.update({'key': key})
            res.append(layerRes)
        return res
    def ages_decomposition_raw(self, parameters):
        grouping = self.define_grouping_for_x_axis(parameters)
        res = []
        for item in parameters.filter_ages():
            counts = [[i, 0] for i in sorted(grouping)]
            count = Person.objects.person_count(parameters.x(), parameters)
            counts = util.add_stacked_counts(count, counts)
            layerRes = {'values': counts}
            key = item
            layerRes.update({'key': key})
            res.append(layerRes)
        return res
    def happys_decomposition_raw(self, parameters):
        grouping = self.define_grouping_for_x_axis(parameters)
        res = []
        for item in parameters.filter_happys():
            counts = [[i, 0] for i in sorted(grouping)]
            count = Person.objects.person_count(parameters.x(), parameters)
            counts = util.add_stacked_counts(count, counts)
            layerRes = {'values': counts}
            key = item
            layerRes.update({'key': key})
            res.append(layerRes)
        return res
    def disgusteds_decomposition_raw(self, parameters):
        grouping = self.define_grouping_for_x_axis(parameters)
        res = []
        for item in parameters.filter_disgusteds():
            counts = [[i, 0] for i in sorted(grouping)]
            count = Person.objects.person_count(parameters.x(), parameters)
            counts = util.add_stacked_counts(count, counts)
            layerRes = {'values': counts}
            key = item
            layerRes.update({'key': key})
            res.append(layerRes)
        return res
    def angrys_decomposition_raw(self, parameters):
        grouping = self.define_grouping_for_x_axis(parameters)
        res = []
        for item in parameters.filter_angrys():
            counts = [[i, 0] for i in sorted(grouping)]
            count = Person.objects.person_count(parameters.x(), parameters)
            counts = util.add_stacked_counts(count, counts)
            layerRes = {'values': counts}
            key = item
            layerRes.update({'key': key})
            res.append(layerRes)
        return res
    def surpriseds_decomposition_raw(self, parameters):
        grouping = self.define_grouping_for_x_axis(parameters)
        res = []
        for item in parameters.filter_surpriseds():
            counts = [[i, 0] for i in sorted(grouping)]
            count = Person.objects.person_count(parameters.x(), parameters)
            counts = util.add_stacked_counts(count, counts)
            layerRes = {'values': counts}
            key = item
            layerRes.update({'key': key})
            rres.append(layerRes)
        return res
    def afraids_decomposition_raw(self, parameters):
        grouping = self.define_grouping_for_x_axis(parameters)
        res = []
        for item in parameters.filter_afraids():
            counts = [[i, 0] for i in sorted(grouping)]
            count = Person.objects.person_count(parameters.x(), parameters)
            counts = util.add_stacked_counts(count, counts)
            layerRes = {'values': counts}
            key = item
            layerRes.update({'key': key})
            rres.append(layerRes)
        return res
    def sads_decomposition_raw(self, parameters):
        grouping = self.define_grouping_for_x_axis(parameters)
        res = []
        for item in parameters.filter_sads():
            counts = [[i, 0] for i in sorted(grouping)]
            count = Person.objects.person_count(parameters.x(), parameters)
            counts = util.add_stacked_counts(count, counts)
            layerRes = {'values': counts}
            key = item
            layerRes.update({'key': key})
            rres.append(layerRes)
        return res

    def define_grouping_for_x_axis(self, parameters):
        grouping = None
        x = parameters.x().lower()
        if x == 'c':
            grouping = parameters.filter_cameras() or []
        elif x == 'd':
            grouping = parameters.filter_days() or range(4,7)
        elif x == 'h':
            grouping = parameters.filter_hours() or range(24)
        elif x == 'mood':
            grouping = parameters.filter_moods() or [40,45,50]
        elif x == 'gen':
            grouping = parameters.filter_genders() or []
        elif x == 'age':
            grouping = parameters.filter_ages() or []
        elif x == 'hap':
            grouping = parameters.filter_happys() or []
        elif x == 'dis':
            grouping = parameters.filter_disgusteds() or []
        elif x == 'ang':
            grouping = parameters.filter_angrys() or []
        elif x == 'sur':
            grouping = parameters.filter_surpriseds() or []
        elif x == 'afr':
            grouping = parameters.filter_afraids() or []
        elif x == 'sad':
            grouping = parameters.filter_sads() or []
        return grouping

# !! EMMA: to check
    def fix_missing_x_groupings(self, res):
        # Find all x_groupings without duplicates
        x_grouping = []
        for r in res:
            x_grouping.extend(x[0] for x in r['values'])
        x_grouping = set(x_grouping)
        x_grouping_len = len(x_grouping)

        for dct in res:
            if len(dct['values']) != x_grouping_len:
                # Not all x_groupings are here.
                values = dict(dct['values'])
                values = [ (x_group, values.get(x_group, 0)) for x_group in x_grouping]
                dct['values'] = values
        return res

####################################

'''
    def hourly_distribution_aggregated_by_week(self, parameters):
        y = parameters.y().lower()
        # get normalized or absolute counts, which should correspond to y axis
        if y == 'nfc':
            return self.hourly_distribution_aggregated_by_week_normalized(parameters)
        elif y == 'fc':
            return self.hourly_distribution_aggregated_by_week_raw(parameters)

    def hourly_distribution_aggregated_by_week_raw(self, parameters):
        counts = [[i, j, 0] for i in range(0, 24) for j in range(0, 54)]

        for camera in parameters.computed_camera_tables():
            count = camera.objects.raw_fish_count('HourWeek', parameters, camera._meta.db_table)

            for hour in count:
                h = int(hour[0])
                w = int(hour[1])
                index = (h * 54) + w
                counts[index][2] = counts[index][2] + hour[2]

        return counts

    def hourly_distribution_aggregated_by_week_normalized(self,parameters):
        counts = self.hourly_distribution_aggregated_by_week_raw(parameters)

        video_counts = Video.objects.video_counts('HourWeek', parameters)

        for c in counts:
            for v in video_counts:
                if c[0] == v[0] and c[1] == v[1]:
                    c[2] = c[2] / v[2]

        return counts
'''